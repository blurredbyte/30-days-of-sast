# .github/workflows/semgrep_scan.yml
# This GitHub Actions workflow runs Semgrep for SAST scanning.

name: Semgrep SAST Scan

permissions:
  contents: read
  security-events: write

on:
  # Triggers the workflow on push events but only for the main/master/develop branches
  push:
    branches: [ "main", "master", "develop" ]
  # Triggers the workflow on pull request events but only for the main/master/develop branches
  pull_request:
    branches: [ "main", "master", "develop" ]
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  semgrep_scan_job:
    name: Run Semgrep Scan
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # We recommend using the official Semgrep Docker image for consistency and ease of use.
    # Make sure to pin to a specific version for stable CI runs.
    # Check for latest versions at https://hub.docker.com/r/returntocorp/semgrep/tags
    container:
      image: returntocorp/semgrep # Example: Pinned to a specific version

    steps:
      # Step 1: Check out code so the action can access it
      - name: Checkout repository
        uses: actions/checkout@v4 # Using a more recent version of checkout

      # Step 2: Run Semgrep SAST Scan
      # The `semgrep ci` command is tailored for CI environments.
      # It will automatically find relevant files and rules.
      # `--config "auto"`: Loads rules from any `.semgrep.yml` or files in `.semgrep/` directory.
      #                    It also loads rules from `.semgrepignore`.
      # `--config "p/python"`: Example of adding a language-specific ruleset from the Semgrep registry.
      #                        Add more for other languages, e.g., "p/javascript", "p/java".
      # `--error`: Semgrep will exit with a non-zero code if findings are present, failing the job.
      #            This is useful for blocking PRs with new vulnerabilities.
      # `--sarif --output=semgrep.sarif`: Outputs results in SARIF format, which can be used by GitHub.
      - name: Run Semgrep
        run: |
          echo "Starting Semgrep scan..."
          # Option 1: Using `semgrep ci` (recommended for most CI setups)
          # This command will scan the entire repository based on language detection
          # and any .semgrep.yml files.
          # Add specific rulesets like p/python, p/go, p/java, p/javascript, etc.
          semgrep ci --config "auto" --config "p/python" --config "p/javascript" --config "p/go" --sarif --output="semgrep.sarif"

          # Option 2: If you want to specify rule files directly (e.g., from the 30-day structure)
          # This requires your daily rule files to be present and correctly pathed.
          # For example, if this workflow is in the root of the 30-day SAST project:
          # semgrep scan --config day05/detect_md5.yml --config day07/fix_eval.yml \
          #   day05/weak_hash.py day07/uses_eval.py \
          #   --sarif --output="semgrep.sarif" --error
          echo "Semgrep scan completed."

      # Step 3: Upload SARIF results to GitHub Code Scanning
      # This step is optional and requires GitHub Advanced Security (GHAS) for private repositories.
      # It's available for public repositories for free.
      # The `if: always()` condition ensures this step runs even if Semgrep finds issues and fails the previous step.
      - name: Upload SARIF to GitHub Code Scanning
        if: always() # Process scan results even if issues are found
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif # Path to the SARIF file generated by Semgrep
          # Optional: Define a category for the Semgrep scan in GitHub Security tab
          category: semgrep-sast

# For this 30-Day SAST project, you might have a root .semgrep.yml file that aggregates
# rules from different days, or the `semgrep ci --config "auto"` command would pick up
# individual .semgrep.yml files if you place them in each `dayXX` folder and Semgrep
# is configured to find them (though typically `auto` looks in `.semgrep/` or root `.semgrep.yml`).

# A good practice for a project like this would be to have a main `.semgrep.yml` at the root:
#
# ```yaml
# # /.semgrep.yml
# rules:
#   # Example: Include all rules from a specific day's YAML file
#   - id: day05-md5-rules
#     rules:
#       - rules_path: day05/detect_md5.yml
#
#   # Example: Include rules from another day
#   - id: day07-eval-rules
#     rules:
#       - rules_path: day07/fix_eval.yml
#
#   # Example: Pull rules directly from the Semgrep Registry
#   - rule: semgrep.python.security.injection.command.subprocess-shell-true # Example registry rule
# ```
# The `semgrep ci --config "auto"` in the workflow would then automatically use this root .semgrep.yml.
